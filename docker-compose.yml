services:
  db:
    image: postgres:16
    env_file: .env.dev
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    ports:
      - "5432:5432"
    volumes:
      - pg_data:/var/lib/postgresql/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U \"$$POSTGRES_USER\" -d \"$$POSTGRES_DB\" || exit 1"]
      interval: 5s
      timeout: 3s
      retries: 30

  web:
    build:
      context: .
      # If you *really* need RAILS_MASTER_KEY at build time, keep args below.
      # Otherwise remove the whole 'args:' block.
      # args:
      #   RAILS_MASTER_KEY: ${RAILS_MASTER_KEY}
    env_file: .env.dev
    depends_on:
      db:
        condition: service_healthy
    ports:
      - "3000:3000"      # use "80:3000" on a VPS for direct IP access
    volumes:
      - storage_data:/app/storage   # fine for dev; not needed if using Cloudinary/S3 in prod
    restart: unless-stopped
    # OPTION A (recommended): let Dockerfile ENTRYPOINT+CMD run. No 'command:' here.
    # OPTION B: if you prefer, explicitly call the script:
    # command: bash -lc 'bin/docker-entrypoint.sh'

volumes:
  pg_data:
  storage_data:
